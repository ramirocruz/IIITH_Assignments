role reader (R, T, S: agent,
            IDR, IDT, IDS,Balnew, dt: text,
            XRS:symmetric_key,
            Hash: hash_func,
            SND, RCV: channel (dy))
played by R def =
local
    State: nat,
    ROT,RROT,SUB:hash_func,
    RN, RA, RB, TR, CR, MR,SR,RQ: text
init 
    State := 0,
    RN := new(), TR := new()
transition
    1. State=0 /\ RCV(start) =|>
        State':= 1 /\
        MR' := ROT( xor (RN, xor(IDT, TR)). xor(TR, IDT)) /\
        CR' := Hash (MR'.RN.IDT) /\
        SND ( {MR',CR', TR} )
    2. State=1 /\ RCV({CT', AuthR', MT', TT'}) =|>
        State' := 2 /\
        SUB(TR.TR') < dt /\
        AuthR' = Hash(CT'.RN.MT'.IDT.TT') /\
        RA' := new() /\
        RB' := new () /\
        TR' := new() /\ 
        MP' := xor(RA', xor(IDS, RB')) /\
        MQ' := xor(XRS, RB') /\ Readercheck' := Hash (xor(xor (RA', IDS), xor(Balnew,RB'.TR'))) /\
        SND({MQ',MP',Readercheck',TR'})

    3. State = 2 /\ RCV({SP',SQ',SS',TS}_XRS) =|>
        SUB(TS,TS') < dt /\
        SR' := RROT(xor(SQ',ROT(TS,XRS)).IDS) /\
        SP' = xor(ROT(TS.xor(IDS,XRS)),ROT(SR'.XRS)) /\
        RQ' := xor(ROT(SR'.IDR),ROT(TS.RN)) /\
        SND({SS',RQ',TS})
end role


role tag(T,R, S: agent,
            IDR, IDT, IDS,Balbc,Balbcrec,Samt, dt: text,
            Hash: hash_func,
            SND, RCV: channel (dy))
played by T def =
local
    State : nat,
    ROT,RROT,SUM,SUB:hash_func,
    Balnew,RN,CR,TT,CT,MT:text,
    SKST:symmetric_key,
    const skst:protocol_id

init
    State := 0
    Balnew := SUM(Balbc.Samt)
%%%%%% Check for the CR'in the 1.
transition
    1. State =0 /\ RCV({MR',CR', TR}) =|> 
        State' := 1 /\
        SUB(TR'.TR) < dt /\
        RN' := xor(RROT(MR'.xor(IDT,TR)),xor(IDT,TR)) /\
        CR'= Hash(MR'.IDT.RN') /\
        TT' := new() /\
        CT' := Hash(xor(RN',xor(IDT,Balnew))) /\
        MT' := ROT(xor(RN',xor(IDS,TT')).xor(TT',IDT) ) /\
        AuthR' := Hash(CT'.RN'.MT'.IDT.TT') /\
        SND({CT',AuthR',MT',TT'})

    2. State = 1 /\ RCV ( {SS',RQ',TS}) =|>
        State' := 2 /\
        SR' := RROT(xor( RQ' ,ROT(TS.RN')).IDR) /\
        SKST' := Hash(xor(xor(IDT,Balnew),xor(SR',IDS))) /\
        SS' = Hash(SKST' . SR' . Balbcrec) /\
        Balnew' := SUM(Balbc. Samt) /\
        secret(SKST',skst,{T,S})
end role

role supplychain (S, T, R: agent,
            IDR, IDT, IDS,Samt,Balbcrec,Balbc, dt: text,
            DB: text set,
            XRS:symmetric_key,
            Hash: hash_func,
            SND, RCV: channel (dy))
played by S def =

local
    State : nat,
    ROT,RROT,SUB:hash_func,
    RB,RA,ScheckA,ScheckB,TS,SR,SP,SQ,SS:text,
    SKST:symmetric_key,
    const skst:protocol_id

init 
    State := 0

transition
    1.State = 0 /\ RECV({MQ',MP',Readercheck',TR'}) =|>
        State' := 1 /\
        SUB(TR'.TR) < dt /\ %%%%%TR'
        in(IDT,DB) /\  %%%%% How to get the Balbcrec
        RB' := xor(XRS,MQ')
        RA' := xor(MP',xor(IDS,RB'))
        ScheckA' := Hash(xor(xor(RA',IDS),xor(Balbcrec,RB'.TR')))
        ScheckB' := Hash(xor(xor(RA',IDS),xor(SUM(Balbcrec.Samt),RB'.TR')))
        ScheckA' = Readercheck' /\
        Balbcrec' := Balbc /\
        SR' := new() /\
        TS' := new() /\
        SP' := xor(ROT(TS'.xor(IDS,XRS)), ROT(SR'.XRS))
        SQ' := xor(ROT(SR'.IDS),ROT(TS'.XRS))
        SKST' := Hash(xor(xor(IDT,Balbcrec'),xor(SR',IDS)))
        SS' := Hash( SKST' . SR' . Balbcrec')
        SND({SP',SQ',SS',TS'}_XRS)
        secret(SKST',skst,{S,T})



    2.State = 0 /\ RECV({MQ',MP',Readercheck',TR'}) =|>
        State' := 2 /\
        SUB(TR'.TR) < dt /\
        not(in(IDT,DB))

    3.State = 0 /\ RECV({MQ',MP',Readercheck',TR'}) =|>
        State' := 1 /\
        SUB(TR'.TR) < dt /\ %%%%%TR'
        in(IDT,DB) /\  %%%%% How to get the Balbcrec
        RB' := xor(XRS,MQ')
        RA' := xor(MP',xor(IDS,RB'))
        ScheckA' := Hash(xor(xor(RA',IDS),xor(Balbcrec,RB'.TR')))
        ScheckB' := Hash(xor(xor(RA',IDS),xor(SUM(Balbcrec.Samt),RB'.TR')))
        ScheckB' = Readercheck' /\
        Balbcrec' := SUM(Balbcrec.Samt) /\ %%%%%Acknowlede kaise??
        SR' := new() /\
        TS' := new() /\
        SP' := xor(ROT(TS'.xor(IDS,XRS)), ROT(SR'.XRS))
        SQ' := xor(ROT(SR'.IDS),ROT(TS'.XRS))
        SKST' := Hash(xor(xor(IDT,Balbcrec'),xor(SR',IDS)))
        SS' := Hash( SKST' . SR' . Balbcrec')
        SND({SP',SQ',SS',TS'}_XRS)
        secret(SKST',skst,{S,T})


end role 
        
role session (S, R, T: agent,
            Hash: hash_func,
            XRS:symmetric_key)


def=
    local RSND, RRECV, SSND, SRECV, TSND, TRECV: channel (dy)
    IDR,IDS,IDT,Samt,Balbcrec,Balbc,Balnew, dt:text
    DB : text set
    composition
        reader (R, T, S,IDR, IDT, IDS,Balnew, dt,XRS,Hash,RSND,RRECV) /\
        tag (T, R, S,IDR, IDT, IDS,Balbc, Balbcrec,Samt,dt,Hash,TSND,TRECV) /\
        supplychain (S, T, R,IDR, IDT, IDS,Samt,Balbcrec,Balbc dt,DB,XRS,Hash,SSND,SRECV)
end role


role environment()
def=
    const reader,tag,supplychain: agent,
        Hash,SUM,SUB,ROT,RROT: hash_func,
        IDR,IDS,IDT: text,
        XRS:symmetric_key,
        skst: protocol_id


    intruder_knowledge = {reader,tag,supplychain, Hash,SUM,SUB,ROT,RROT,IDR,IDS,IDT}


    composition
        session(supplychain, reader, tag, Hash,XRS) /\
        session(i, reader, tag, Hash,XRS) /\
        session(supplychain, i, tag, Hash,XRS) /\
        session(supplychain, reader, i, Hash,XRS)
end role

goal
%%% Confidentiality (privacy)
secrecy_of skst

end goal
environment()